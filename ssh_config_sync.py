#!/usr/bin/env python3
"""
SSH Config Bidirectional Sync Tool

This script intelligently syncs SSH config files between ~/Dropbox/.ssh/config
and ~/.ssh/config in both directions, ensuring the newest configuration is
always propagated and avoiding duplicate entries.
"""

import os
import shutil
import re
import hashlib
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple
import argparse
import logging

class SSHConfigParser:
    """Parser for SSH config files that can extract and merge Host entries."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def parse_config(self, config_path: Path) -> Dict[str, Dict[str, str]]:
        """
        Parse SSH config file and return dictionary of Host entries.
        
        Args:
            config_path: Path to SSH config file
            
        Returns:
            Dictionary with host names as keys and their configurations as values
        """
        hosts = {}
        current_host = None
        current_config = {}
        
        if not config_path.exists():
            return hosts
            
        try:
            with open(config_path, 'r') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    
                    # Skip empty lines and comments
                    if not line or line.startswith('#'):
                        continue
                    
                    # Check for Host directive
                    if line.lower().startswith('host '):
                        # Save previous host if exists
                        if current_host and current_config:
                            hosts[current_host] = current_config.copy()
                        
                        # Start new host
                        current_host = line.split(None, 1)[1]
                        current_config = {}
                        continue
                    
                    # Parse configuration options
                    if current_host and ' ' in line:
                        parts = line.split(None, 1)
                        if len(parts) == 2:
                            key, value = parts
                            current_config[key.lower()] = value
                
                # Don't forget the last host
                if current_host and current_config:
                    hosts[current_host] = current_config.copy()
                    
        except Exception as e:
            self.logger.error(f"Error parsing config file {config_path}: {e}")
            
        return hosts
    
    def write_config(self, hosts: Dict[str, Dict[str, str]], config_path: Path):
        """
        Write SSH config dictionary to file.
        
        Args:
            hosts: Dictionary of host configurations
            config_path: Path to write the config file
        """
        try:
            # Ensure directory exists
            config_path.parent.mkdir(parents=True, exist_ok=True)
            
            with open(config_path, 'w') as f:
                f.write("# SSH Config - Generated by ssh_config_sync.py\n")
                f.write(f"# Last updated: {datetime.now().isoformat()}\n\n")
                
                for host, config in hosts.items():
                    f.write(f"Host {host}\n")
                    for key, value in config.items():
                        # Capitalize first letter of key for standard formatting
                        formatted_key = key.capitalize()
                        f.write(f"    {formatted_key} {value}\n")
                    f.write("\n")
                    
        except Exception as e:
            self.logger.error(f"Error writing config file {config_path}: {e}")
            raise

class SSHConfigSync:
    """Main class for syncing SSH configs between Dropbox and local directory."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.parser = SSHConfigParser()
        
        # Define paths
        self.dropbox_ssh_dir = Path.home() / "Dropbox" / ".ssh"
        self.dropbox_config = self.dropbox_ssh_dir / "config"
        self.local_ssh_dir = Path.home() / ".ssh"
        self.local_config = self.local_ssh_dir / "config"
        self.hash_tracking_file = self.dropbox_ssh_dir / "config_history.json"
        
    def check_paths(self) -> Tuple[bool, bool]:
        """
        Check if required paths exist.
        
        Returns:
            Tuple of (dropbox_config_exists, local_config_exists)
        """
        dropbox_exists = self.dropbox_config.exists()
        local_exists = self.local_config.exists()
        
        self.logger.info(f"Dropbox config exists: {dropbox_exists} ({self.dropbox_config})")
        self.logger.info(f"Local config exists: {local_exists} ({self.local_config})")
        
        return dropbox_exists, local_exists
    
    def calculate_config_hash(self, config_path: Path) -> Optional[str]:
        """
        Calculate SHA256 hash of a config file.
        
        Args:
            config_path: Path to the config file
            
        Returns:
            Hex string of SHA256 hash, or None if file doesn't exist
        """
        if not config_path.exists():
            return None
            
        try:
            with open(config_path, 'rb') as f:
                content = f.read()
                return hashlib.sha256(content).hexdigest()
        except Exception as e:
            self.logger.error(f"Error calculating hash for {config_path}: {e}")
            return None
    
    def load_hash_tracking(self) -> Dict[str, Dict]:
        """
        Load the hash tracking metadata from Dropbox.
        
        Returns:
            Dictionary with hash as key and metadata as value
        """
        if not self.hash_tracking_file.exists():
            return {}
            
        try:
            with open(self.hash_tracking_file, 'r') as f:
                return json.load(f)
        except Exception as e:
            self.logger.warning(f"Error loading hash tracking file: {e}")
            return {}
    
    def save_hash_tracking(self, tracking_data: Dict[str, Dict]):
        """
        Save the hash tracking metadata to Dropbox.
        
        Args:
            tracking_data: Dictionary with hash as key and metadata as value
        """
        try:
            # Ensure directory exists
            self.hash_tracking_file.parent.mkdir(parents=True, exist_ok=True)
            
            with open(self.hash_tracking_file, 'w') as f:
                json.dump(tracking_data, f, indent=2, sort_keys=True)
                
        except Exception as e:
            self.logger.error(f"Error saving hash tracking file: {e}")
            
    def update_hash_tracking(self, config_hash: str, source_location: str, timestamp: float):
        """
        Update hash tracking with a new or existing config hash.
        
        Args:
            config_hash: SHA256 hash of the config
            source_location: Where this hash was seen ('local' or 'dropbox')
            timestamp: When this hash was seen
        """
        tracking_data = self.load_hash_tracking()
        
        if config_hash not in tracking_data:
            # First time seeing this hash
            tracking_data[config_hash] = {
                'first_seen': datetime.fromtimestamp(timestamp).isoformat(),
                'first_location': source_location,
                'last_seen': datetime.fromtimestamp(timestamp).isoformat(),
                'locations': [source_location]
            }
            self.logger.info(f"New config hash {config_hash[:8]}... first seen in {source_location}")
        else:
            # Update existing hash tracking
            tracking_data[config_hash]['last_seen'] = datetime.fromtimestamp(timestamp).isoformat()
            if source_location not in tracking_data[config_hash]['locations']:
                tracking_data[config_hash]['locations'].append(source_location)
                self.logger.info(f"Config hash {config_hash[:8]}... now seen in {source_location}")
        
        self.save_hash_tracking(tracking_data)
    
    def configs_are_identical(self) -> bool:
        """
        Check if local and Dropbox configs have identical content (ignoring timestamps).
        
        Returns:
            True if configs have identical content, False otherwise
        """
        local_hash = self.calculate_config_hash(self.local_config)
        dropbox_hash = self.calculate_config_hash(self.dropbox_config)
        
        if local_hash is None or dropbox_hash is None:
            return False
            
        identical = local_hash == dropbox_hash
        
        if identical:
            self.logger.info(f"Configs are identical (hash: {local_hash[:8]}...)")
        else:
            self.logger.info(f"Configs differ (local: {local_hash[:8]}..., dropbox: {dropbox_hash[:8]}...)")
            
        return identical
    
    def determine_sync_direction(self) -> str:
        """
        Determine which direction to sync based on content hashes and file timestamps.
        
        Returns:
            'dropbox_to_local' if Dropbox is newer or local doesn't exist
            'local_to_dropbox' if local is newer or Dropbox doesn't exist
            'no_sync' if both files exist and have identical content or same timestamp
            'error' if neither file exists
        """
        local_exists = self.local_config.exists()
        dropbox_exists = self.dropbox_config.exists()
        
        if not local_exists and not dropbox_exists:
            self.logger.warning("Neither local nor Dropbox config exists")
            return 'error'
        
        if not local_exists:
            self.logger.info("No local config exists, will copy from Dropbox")
            return 'dropbox_to_local'
            
        if not dropbox_exists:
            self.logger.info("No Dropbox config exists, will copy from local")
            return 'local_to_dropbox'
            
        # Both exist, first check if content is identical
        if self.configs_are_identical():
            self.logger.info("Configs have identical content, no sync needed")
            return 'no_sync'
            
        # Content differs, compare timestamps
        dropbox_mtime = self.dropbox_config.stat().st_mtime
        local_mtime = self.local_config.stat().st_mtime
        
        self.logger.info(f"Dropbox config modified: {datetime.fromtimestamp(dropbox_mtime)}")
        self.logger.info(f"Local config modified: {datetime.fromtimestamp(local_mtime)}")
        
        if abs(dropbox_mtime - local_mtime) < 1:  # Within 1 second, consider same
            self.logger.info("Files have same timestamp but different content, no sync to avoid conflicts")
            return 'no_sync'
        elif dropbox_mtime > local_mtime:
            self.logger.info("Dropbox config is newer, syncing to local")
            return 'dropbox_to_local'
        else:
            self.logger.info("Local config is newer, syncing to Dropbox")
            return 'local_to_dropbox'
    
    def backup_config(self, config_path: Path):
        """Create a backup of the specified config before modifying."""
        if config_path.exists():
            backup_path = config_path.with_suffix('.config.backup')
            shutil.copy2(config_path, backup_path)
            self.logger.info(f"Created backup: {backup_path}")
    
    def backup_local_config(self):
        """Create a backup of the local config before modifying."""
        self.backup_config(self.local_config)
    
    def backup_dropbox_config(self):
        """Create a backup of the Dropbox config before modifying."""
        self.backup_config(self.dropbox_config)
    
    def merge_configs(self, dropbox_hosts: Dict[str, Dict[str, str]], 
                     local_hosts: Dict[str, Dict[str, str]]) -> Dict[str, Dict[str, str]]:
        """
        Intelligently merge Dropbox and local SSH configs.
        
        Args:
            dropbox_hosts: Host configurations from Dropbox
            local_hosts: Host configurations from local file
            
        Returns:
            Merged host configurations
        """
        merged = local_hosts.copy()
        
        for host, config in dropbox_hosts.items():
            if host in merged:
                self.logger.info(f"Host '{host}' already exists locally, merging configurations")
                # Merge configurations, Dropbox takes precedence for conflicts
                merged_config = merged[host].copy()
                merged_config.update(config)
                merged[host] = merged_config
            else:
                self.logger.info(f"Adding new host '{host}' from Dropbox")
                merged[host] = config.copy()
        
        return merged
    
    def sync(self, dry_run: bool = False) -> bool:
        """
        Perform the SSH config sync operation in both directions.
        
        Args:
            dry_run: If True, only show what would be done without making changes
            
        Returns:
            True if sync was successful, False otherwise
        """
        try:
            dropbox_exists, local_exists = self.check_paths()
            
            # Track existing config hashes for history
            if local_exists:
                local_hash = self.calculate_config_hash(self.local_config)
                if local_hash:
                    self.update_hash_tracking(local_hash, "local", self.local_config.stat().st_mtime)
                    
            if dropbox_exists:
                dropbox_hash = self.calculate_config_hash(self.dropbox_config)
                if dropbox_hash:
                    self.update_hash_tracking(dropbox_hash, "dropbox", self.dropbox_config.stat().st_mtime)
            
            # Determine sync direction
            sync_direction = self.determine_sync_direction()
            
            if sync_direction == 'error':
                self.logger.error("No config files found to sync")
                return False
            
            if sync_direction == 'no_sync':
                self.logger.info("Configs are in sync, no changes needed")
                return True
            
            # Parse configurations based on sync direction
            if sync_direction == 'dropbox_to_local':
                self.logger.info("Syncing from Dropbox to local...")
                source_hosts = self.parser.parse_config(self.dropbox_config)
                target_hosts = self.parser.parse_config(self.local_config) if local_exists else {}
                merged_hosts = self.merge_configs(source_hosts, target_hosts)
                target_path = self.local_config
                
                self.logger.info(f"Found {len(source_hosts)} hosts in Dropbox config")
                self.logger.info(f"Found {len(target_hosts)} hosts in local config")
                
            else:  # local_to_dropbox
                self.logger.info("Syncing from local to Dropbox...")
                source_hosts = self.parser.parse_config(self.local_config)
                target_hosts = self.parser.parse_config(self.dropbox_config) if dropbox_exists else {}
                merged_hosts = self.merge_configs(source_hosts, target_hosts)
                target_path = self.dropbox_config
                
                self.logger.info(f"Found {len(source_hosts)} hosts in local config")
                self.logger.info(f"Found {len(target_hosts)} hosts in Dropbox config")
            
            self.logger.info(f"Merged result contains {len(merged_hosts)} hosts")
            
            if dry_run:
                direction_str = "local" if sync_direction == 'dropbox_to_local' else "Dropbox"
                self.logger.info(f"DRY RUN - Would update {direction_str} config with:")
                for host in merged_hosts:
                    if host not in target_hosts:
                        self.logger.info(f"  + NEW: {host}")
                    elif host in source_hosts:
                        self.logger.info(f"  ~ UPDATED: {host}")
                return True
            
            # Create backup and write merged config
            if sync_direction == 'dropbox_to_local':
                self.backup_local_config()
            else:
                self.backup_dropbox_config()
                # Ensure Dropbox .ssh directory exists
                self.dropbox_ssh_dir.mkdir(parents=True, exist_ok=True)
            
            self.parser.write_config(merged_hosts, target_path)
            
            # Update hash tracking for the newly written config
            new_hash = self.calculate_config_hash(target_path)
            if new_hash:
                target_location = "local" if sync_direction == 'dropbox_to_local' else "dropbox"
                self.update_hash_tracking(new_hash, target_location, target_path.stat().st_mtime)
            
            direction_str = "Dropbox → Local" if sync_direction == 'dropbox_to_local' else "Local → Dropbox"
            self.logger.info(f"SSH config sync completed successfully ({direction_str})")
            return True
            
        except Exception as e:
            self.logger.error(f"Error during sync: {e}")
            return False
    
    def show_hash_history(self):
        """Display the config hash history."""
        tracking_data = self.load_hash_tracking()
        
        if not tracking_data:
            self.logger.info("No config hash history found")
            return
            
        self.logger.info("=== SSH Config Hash History ===")
        
        # Sort by first_seen date
        sorted_hashes = sorted(
            tracking_data.items(),
            key=lambda x: x[1]['first_seen']
        )
        
        for config_hash, data in sorted_hashes:
            self.logger.info(f"\nHash: {config_hash[:12]}...")
            self.logger.info(f"  First seen: {data['first_seen']} in {data['first_location']}")
            self.logger.info(f"  Last seen: {data['last_seen']}")
            self.logger.info(f"  Locations: {', '.join(data['locations'])}")
            
        self.logger.info(f"\nTotal unique configs tracked: {len(tracking_data)}")

def setup_logging(verbose: bool = False):
    """Setup logging configuration."""
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Bidirectionally sync SSH config between Dropbox and local SSH directory"
    )
    parser.add_argument(
        '--dry-run', 
        action='store_true',
        help="Show what would be done without making changes"
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true', 
        help="Enable verbose logging"
    )
    parser.add_argument(
        '--show-history',
        action='store_true',
        help="Show config hash history and exit"
    )
    
    args = parser.parse_args()
    
    setup_logging(args.verbose)
    logger = logging.getLogger(__name__)
    
    sync_tool = SSHConfigSync()
    
    if args.show_history:
        sync_tool.show_hash_history()
        return 0
    
    logger.info("Starting SSH Config Dropbox Sync")
    
    success = sync_tool.sync(dry_run=args.dry_run)
    
    if success:
        logger.info("Sync completed successfully")
        return 0
    else:
        logger.error("Sync failed")
        return 1

if __name__ == "__main__":
    exit(main()) 
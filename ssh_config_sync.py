#!/usr/bin/env python3
"""
SSH Config Bidirectional Sync Tool

This script intelligently syncs SSH config files between ~/Dropbox/.ssh/config
and ~/.ssh/config in both directions, ensuring the newest configuration is
always propagated and avoiding duplicate entries.
"""

import os
import shutil
import re
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple
import argparse
import logging

class SSHConfigParser:
    """Parser for SSH config files that can extract and merge Host entries."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def parse_config(self, config_path: Path) -> Dict[str, Dict[str, str]]:
        """
        Parse SSH config file and return dictionary of Host entries.
        
        Args:
            config_path: Path to SSH config file
            
        Returns:
            Dictionary with host names as keys and their configurations as values
        """
        hosts = {}
        current_host = None
        current_config = {}
        
        if not config_path.exists():
            return hosts
            
        try:
            with open(config_path, 'r') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    
                    # Skip empty lines and comments
                    if not line or line.startswith('#'):
                        continue
                    
                    # Check for Host directive
                    if line.lower().startswith('host '):
                        # Save previous host if exists
                        if current_host and current_config:
                            hosts[current_host] = current_config.copy()
                        
                        # Start new host
                        current_host = line.split(None, 1)[1]
                        current_config = {}
                        continue
                    
                    # Parse configuration options
                    if current_host and ' ' in line:
                        parts = line.split(None, 1)
                        if len(parts) == 2:
                            key, value = parts
                            current_config[key.lower()] = value
                
                # Don't forget the last host
                if current_host and current_config:
                    hosts[current_host] = current_config.copy()
                    
        except Exception as e:
            self.logger.error(f"Error parsing config file {config_path}: {e}")
            
        return hosts
    
    def write_config(self, hosts: Dict[str, Dict[str, str]], config_path: Path):
        """
        Write SSH config dictionary to file.
        
        Args:
            hosts: Dictionary of host configurations
            config_path: Path to write the config file
        """
        try:
            # Ensure directory exists
            config_path.parent.mkdir(parents=True, exist_ok=True)
            
            with open(config_path, 'w') as f:
                f.write("# SSH Config - Generated by ssh_config_sync.py\n")
                f.write(f"# Last updated: {datetime.now().isoformat()}\n\n")
                
                for host, config in hosts.items():
                    f.write(f"Host {host}\n")
                    for key, value in config.items():
                        # Capitalize first letter of key for standard formatting
                        formatted_key = key.capitalize()
                        f.write(f"    {formatted_key} {value}\n")
                    f.write("\n")
                    
        except Exception as e:
            self.logger.error(f"Error writing config file {config_path}: {e}")
            raise

class SSHConfigSync:
    """Main class for syncing SSH configs between Dropbox and local directory."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.parser = SSHConfigParser()
        
        # Define paths
        self.dropbox_ssh_dir = Path.home() / "Dropbox" / ".ssh"
        self.dropbox_config = self.dropbox_ssh_dir / "config"
        self.local_ssh_dir = Path.home() / ".ssh"
        self.local_config = self.local_ssh_dir / "config"
        
    def check_paths(self) -> Tuple[bool, bool]:
        """
        Check if required paths exist.
        
        Returns:
            Tuple of (dropbox_config_exists, local_config_exists)
        """
        dropbox_exists = self.dropbox_config.exists()
        local_exists = self.local_config.exists()
        
        self.logger.info(f"Dropbox config exists: {dropbox_exists} ({self.dropbox_config})")
        self.logger.info(f"Local config exists: {local_exists} ({self.local_config})")
        
        return dropbox_exists, local_exists
    
    def determine_sync_direction(self) -> str:
        """
        Determine which direction to sync based on file timestamps.
        
        Returns:
            'dropbox_to_local' if Dropbox is newer or local doesn't exist
            'local_to_dropbox' if local is newer or Dropbox doesn't exist
            'no_sync' if both files exist and have same timestamp
            'error' if neither file exists
        """
        local_exists = self.local_config.exists()
        dropbox_exists = self.dropbox_config.exists()
        
        if not local_exists and not dropbox_exists:
            self.logger.warning("Neither local nor Dropbox config exists")
            return 'error'
        
        if not local_exists:
            self.logger.info("No local config exists, will copy from Dropbox")
            return 'dropbox_to_local'
            
        if not dropbox_exists:
            self.logger.info("No Dropbox config exists, will copy from local")
            return 'local_to_dropbox'
            
        # Both exist, compare timestamps
        dropbox_mtime = self.dropbox_config.stat().st_mtime
        local_mtime = self.local_config.stat().st_mtime
        
        self.logger.info(f"Dropbox config modified: {datetime.fromtimestamp(dropbox_mtime)}")
        self.logger.info(f"Local config modified: {datetime.fromtimestamp(local_mtime)}")
        
        if abs(dropbox_mtime - local_mtime) < 1:  # Within 1 second, consider same
            self.logger.info("Files have same timestamp, no sync needed")
            return 'no_sync'
        elif dropbox_mtime > local_mtime:
            self.logger.info("Dropbox config is newer, syncing to local")
            return 'dropbox_to_local'
        else:
            self.logger.info("Local config is newer, syncing to Dropbox")
            return 'local_to_dropbox'
    
    def backup_config(self, config_path: Path):
        """Create a backup of the specified config before modifying."""
        if config_path.exists():
            backup_path = config_path.with_suffix('.config.backup')
            shutil.copy2(config_path, backup_path)
            self.logger.info(f"Created backup: {backup_path}")
    
    def backup_local_config(self):
        """Create a backup of the local config before modifying."""
        self.backup_config(self.local_config)
    
    def backup_dropbox_config(self):
        """Create a backup of the Dropbox config before modifying."""
        self.backup_config(self.dropbox_config)
    
    def merge_configs(self, dropbox_hosts: Dict[str, Dict[str, str]], 
                     local_hosts: Dict[str, Dict[str, str]]) -> Dict[str, Dict[str, str]]:
        """
        Intelligently merge Dropbox and local SSH configs.
        
        Args:
            dropbox_hosts: Host configurations from Dropbox
            local_hosts: Host configurations from local file
            
        Returns:
            Merged host configurations
        """
        merged = local_hosts.copy()
        
        for host, config in dropbox_hosts.items():
            if host in merged:
                self.logger.info(f"Host '{host}' already exists locally, merging configurations")
                # Merge configurations, Dropbox takes precedence for conflicts
                merged_config = merged[host].copy()
                merged_config.update(config)
                merged[host] = merged_config
            else:
                self.logger.info(f"Adding new host '{host}' from Dropbox")
                merged[host] = config.copy()
        
        return merged
    
    def sync(self, dry_run: bool = False) -> bool:
        """
        Perform the SSH config sync operation in both directions.
        
        Args:
            dry_run: If True, only show what would be done without making changes
            
        Returns:
            True if sync was successful, False otherwise
        """
        try:
            dropbox_exists, local_exists = self.check_paths()
            
            # Determine sync direction
            sync_direction = self.determine_sync_direction()
            
            if sync_direction == 'error':
                self.logger.error("No config files found to sync")
                return False
            
            if sync_direction == 'no_sync':
                self.logger.info("Configs are in sync, no changes needed")
                return True
            
            # Parse configurations based on sync direction
            if sync_direction == 'dropbox_to_local':
                self.logger.info("Syncing from Dropbox to local...")
                source_hosts = self.parser.parse_config(self.dropbox_config)
                target_hosts = self.parser.parse_config(self.local_config) if local_exists else {}
                merged_hosts = self.merge_configs(source_hosts, target_hosts)
                target_path = self.local_config
                
                self.logger.info(f"Found {len(source_hosts)} hosts in Dropbox config")
                self.logger.info(f"Found {len(target_hosts)} hosts in local config")
                
            else:  # local_to_dropbox
                self.logger.info("Syncing from local to Dropbox...")
                source_hosts = self.parser.parse_config(self.local_config)
                target_hosts = self.parser.parse_config(self.dropbox_config) if dropbox_exists else {}
                merged_hosts = self.merge_configs(source_hosts, target_hosts)
                target_path = self.dropbox_config
                
                self.logger.info(f"Found {len(source_hosts)} hosts in local config")
                self.logger.info(f"Found {len(target_hosts)} hosts in Dropbox config")
            
            self.logger.info(f"Merged result contains {len(merged_hosts)} hosts")
            
            if dry_run:
                direction_str = "local" if sync_direction == 'dropbox_to_local' else "Dropbox"
                self.logger.info(f"DRY RUN - Would update {direction_str} config with:")
                for host in merged_hosts:
                    if host not in target_hosts:
                        self.logger.info(f"  + NEW: {host}")
                    elif host in source_hosts:
                        self.logger.info(f"  ~ UPDATED: {host}")
                return True
            
            # Create backup and write merged config
            if sync_direction == 'dropbox_to_local':
                self.backup_local_config()
            else:
                self.backup_dropbox_config()
                # Ensure Dropbox .ssh directory exists
                self.dropbox_ssh_dir.mkdir(parents=True, exist_ok=True)
            
            self.parser.write_config(merged_hosts, target_path)
            
            direction_str = "Dropbox → Local" if sync_direction == 'dropbox_to_local' else "Local → Dropbox"
            self.logger.info(f"SSH config sync completed successfully ({direction_str})")
            return True
            
        except Exception as e:
            self.logger.error(f"Error during sync: {e}")
            return False

def setup_logging(verbose: bool = False):
    """Setup logging configuration."""
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Bidirectionally sync SSH config between Dropbox and local SSH directory"
    )
    parser.add_argument(
        '--dry-run', 
        action='store_true',
        help="Show what would be done without making changes"
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true', 
        help="Enable verbose logging"
    )
    
    args = parser.parse_args()
    
    setup_logging(args.verbose)
    logger = logging.getLogger(__name__)
    
    logger.info("Starting SSH Config Dropbox Sync")
    
    sync_tool = SSHConfigSync()
    success = sync_tool.sync(dry_run=args.dry_run)
    
    if success:
        logger.info("Sync completed successfully")
        return 0
    else:
        logger.error("Sync failed")
        return 1

if __name__ == "__main__":
    exit(main()) 